trigger:
  branches:
    include:
      - master
  paths:
    exclude:
      - /.azure-pipelines/azure-pipelines-frontend.yml
      - /packages/client/*
      - /packages/client-e2e/*

pool:
  vmImage: 'ubuntu-latest'

steps:
  - task: NodeTool@0
    inputs:
      versionSpec: '14.6.0'
    displayName: 'Install Node.js 14.6.0'

  # This is included in package.json, but only under devDependencies, so this (production!) build won't see it.
  # As a workaround, install it globally
  - script: yarn global add wasm-pack
    displayName: 'Install wasm-pack'

  - task: Cache@2
    inputs:
      # Cache the tarred node_modules.xz file.
      # Note that the cache key is the hash of of yarn.lock. If the lockfile changes, the cache gets invalidated.
      key: 'v2 | yarn | "$(Agent.OS)" | $(Build.SourcesDirectory)/yarn.lock'
      path: '$(Build.SourcesDirectory)/tarred_node_modules'
      cacheHitVar: 'NodeCacheRestored'
    displayName: 'Cache node_modules'

  # Untar the cached node_modules folder if we had a cache hit
  - script: tar -xfv $(Build.SourcesDirectory)/tarred_node_modules/node_modules.tar.xz --directory=$(Build.SourcesDirectory)
    condition: eq(variables['NodeCacheRestored'], 'true')
    displayName: 'Untar node_modules.xz'

  # Cache word_counter's output
  - task: Cache@2
    inputs:
      key: 'cargo | "$(Agent.OS)" | $(Build.SourcesDirectory)/native/word_counter/Cargo.lock'
      path: '$(Build.SourcesDirectory)/native/word_counter/target'
      cacheHitVar: 'WordCounterCacheRestored'
    displayName: 'Cache word_counter output'

  # Cache html_sanitizer's output
  - task: Cache@2
    inputs:
      key: 'cargo | "$(Agent.OS)" | $(Build.SourcesDirectory)/native/html_sanitizer/Cargo.lock'
      path: '$(Build.SourcesDirectory)/native/html_sanitizer/target'
      cacheHitVar: 'WordCounterCacheRestored'
    displayName: 'Cache html_sanitizer output'

  # Install production-only packages if the cache doesn't exist, or is out of date.
  - script: yarn install --non-interactive --frozen-lockfile
    condition: ne(variables['NodeCacheRestored'], 'true')
    displayName: 'Yarn install'

  # Build the project
  - script: yarn build:ci:server
    displayName: 'Build'

  # Publish the built /dist/packages/server folder to make it available for release
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(Build.SourcesDirectory)/dist/packages/server'
      ArtifactName: 'backend-dist'
      publishLocation: 'Container'
    displayName: 'Publish /dist/packages/server folder'

  # Collect node_modules into an archive, or publishing takes forEVER
  # (but only if we didn't restore the .tar.xz file from cache already)
  # Put it into the tarred_node_modules folder so the Cache task has a folder to work with
  - task: ArchiveFiles@2
    condition: ne(variables['NodeCacheRestored'], 'true')
    inputs:
      rootFolderOrFile: '$(Build.SourcesDirectory)/node_modules'
      archiveType: tar
      tarCompression: xz
      archiveFile: '$(Build.SourcesDirectory)/tarred_node_modules/node_modules.tar.xz'  

  # Publish the built /node_modules folder to make it available for release
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(Build.SourcesDirectory)/tarred_node_modules/node_modules.tar.xz'
      ArtifactName: 'backend-node_modules'
      publishLocation: 'Container'
    displayName: 'Publish tarred /node_modules folder'

  # Also publish the latest pm2 config
  - task: PublishBuildArtifacts@1
    inputs:
      PathtoPublish: '$(Build.SourcesDirectory)/pm2.config.js'
      ArtifactName: 'pm2-config'
      publishLocation: 'Container'
    displayName: 'Publish pm2 config'
